# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `terrapin` gem.
# Please instead update this file by running `bin/tapioca gem terrapin`.

module Terrapin; end

class Terrapin::CommandLine
  def initialize(binary, params = T.unsafe(nil), options = T.unsafe(nil)); end

  def command(interpolations = T.unsafe(nil)); end
  def command_error_output; end
  def command_output; end
  def exit_status; end
  def output; end
  def run(interpolations = T.unsafe(nil)); end
  def runner; end

  private

  def bit_bucket; end
  def colored(text, ansi_color = T.unsafe(nil)); end
  def environment; end
  def execute(command); end
  def interpolate(pattern, interpolations); end
  def log(text); end
  def os_path_prefix; end
  def path_prefix; end
  def runner_options; end
  def shell_quote(string); end
  def shell_quote_all_values(values); end
  def stringify_keys(hash); end
  def unix_path_prefix; end
  def windows_path_prefix; end

  class << self
    def environment; end
    def fake!; end
    def logger; end
    def logger=(_arg0); end
    def path; end
    def path=(supplemental_path); end
    def runner; end
    def runner=(_arg0); end
    def runner_options; end
    def unfake!; end

    private

    def best_runner; end
  end
end

class Terrapin::CommandLine::BackticksRunner
  def call(command, env = T.unsafe(nil), options = T.unsafe(nil)); end
  def supported?; end

  private

  def with_modified_environment(env, &block); end

  class << self
    def supported?; end
  end
end

class Terrapin::CommandLine::FakeRunner
  def initialize; end

  def call(command, env = T.unsafe(nil), options = T.unsafe(nil)); end
  def commands; end
  def ran?(predicate_command); end
  def supported?; end

  class << self
    def supported?; end
  end
end

class Terrapin::CommandLine::MultiPipe
  def initialize; end

  def output; end
  def pipe_options; end
  def read_and_then(&block); end

  private

  def close_read; end
  def close_write; end
  def read; end
  def read_stream(io); end
end

class Terrapin::CommandLine::Output
  def initialize(output = T.unsafe(nil), error_output = T.unsafe(nil)); end

  def error_output; end
  def output; end
  def to_s; end
end

class Terrapin::CommandLine::PopenRunner
  def call(command, env = T.unsafe(nil), options = T.unsafe(nil)); end
  def supported?; end

  private

  def with_modified_environment(env, &block); end

  class << self
    def supported?; end
  end
end

class Terrapin::CommandLine::PosixRunner
  def call(command, env = T.unsafe(nil), options = T.unsafe(nil)); end
  def supported?; end

  private

  def spawn(*args); end
  def waitpid(pid); end

  class << self
    def available?; end
    def supported?; end

    private

    def posix_spawn_gem_available?; end
  end
end

class Terrapin::CommandLine::ProcessRunner
  def call(command, env = T.unsafe(nil), options = T.unsafe(nil)); end
  def supported?; end

  private

  def spawn(*args); end
  def waitpid(pid); end

  class << self
    def available?; end
    def supported?; end
  end
end

class Terrapin::CommandLineError < ::StandardError; end
class Terrapin::CommandNotFoundError < ::Terrapin::CommandLineError; end
class Terrapin::ExitStatusError < ::Terrapin::CommandLineError; end
class Terrapin::InterpolationError < ::Terrapin::CommandLineError; end
Terrapin::OS = T.let(T.unsafe(nil), Terrapin::OSDetector)

class Terrapin::OSDetector
  def arch; end
  def java?; end
  def path_separator; end
  def unix?; end
  def windows?; end
end
